.. ===============================================================
   Bit-reproducible methods for dimensional and rotational testing
   ===============================================================

==========================================
Dimensional and Rotational Testing of MOM6
==========================================

:authors:
   - Robert Hallberg
   - **Marshall Ward**
   - Alistair Adcroft
:description: An overview of MOM6 bit reproducibility methods.
:date: 2021-09-23
:url: https://marshallward.org/fortrancon2021/index.html
:preface:
   Will talk about (bit repro testing)

   Although I am presenting...

   Robert Hallberg is responsible for many of the ideas here

   Had the audacity to assert that this was achievable.

   and fleshed them out with Alistair Adcroft, both at GFDL in Princeton.

   I just came in at the end and implemented them.


Global Modeling
===============

.. image:: media/mom6_relvort.mp4
   :width: 85%

.. notes::

   GFDL CM4 model:
      - coupled to MOM6

   Phenomena on this model:
      - Equatorial Waves
         - Large, very fast
         - shelf-reflecting => ENSO
      - Southern Ocean
         - Slower, turbulent eddies
         - Strong topographic driven
      - Western Boundary Currents
         - Gulf Stream (Eastern US), Kuroshio (Japan)
         - Agulhas (Africa) -> eddies
         - Benguela (S.America), EAC (Australia)
      - Tropical storms (from atm)

   Things you cannot see
      - very fast, very large scale, tidal waves
      - Meridional overturning circulation


.. Regional Modeling
   =================
   
   .. image:: media/mom6_regional.mp4
      :width: 90%
   
   .. notes::
   
      Say something interesting...
   
      - Fisheries
      - Refineries (Gulf of Mexico)
      - ...?


Ocean Dynamics
==============

.. image:: img/ocn_finite_volume.png

.. notes::

   - *Very strong* parallels to atmosphere dynamics

      - Ocean is like an "upside down atmosphere"

   - Primarily finite volume:

      - Momentum balance ("newton's law")

      - Hydrostatic balance => No elliptic PDEs (horizontally)

      - Advection of heat, salt, biomass, etc

      - Usually Boussinesq (volume-conserving)

      - Coriolis force is a major driver

   - External forcing (heat, precip, wind)

      Sometimes prescribed, sometimes from another model

   - Many "submodels":

      - "LES"-like parameterizations

      - Complex vertical mixing

      - Boundary layers in surface, shelf


Layered Dynamics
================

.. image:: img/mom6_vcoord.png
   :width: 75%




Lagrangian Remap
================

.. image:: img/lagrange_remap.png


Chaotic Dynamics
================

.. figure:: media/pv.mp4
   :target: https://www.youtube.com/watch?v=buI6mKzkbs0


Motivation
==========

* Accurate preservation of tracers

* Sustain long simulations over decades, centuries

* Residual noise can cause chaotic growth

* Operational work needs robust testing

Reproducible floating point arithmetic is essential


Solution verification
=====================

``ocean.stats``

.. code:: bash

  Step   Days   Energy/Mass [m2 s-2]     Mean Sea Level [m]   ...

     0   0.00   7.2161166068132286E-27   1.8190E-12           ...
    12   0.50   2.7781004671136538E-04   1.1369E-12           ...
    24   1.00   2.7734897826598717E-04   1.8190E-12           ...

Based on global metrics (energy, mass, etc)


Diagnostic verification
=======================

``chksum_diag``::

     u-point: ocean_model-u
       min  = -6.7187595818683776E-03  max  =  3.3480219779204019E-02
       mean =  1.1239682303793666E-04  bits = 21851
     v-point: ocean_model-v
       min  = -8.3469699425156359E-03  max  =  6.8420831486068704E-03
       mean =  1.2076392816784489E-03  bits = 18606
     h-point: ocean_model-h
       min  =  9.9999999999999915E-04  max  =  5.6265092225099863E+02
       mean =  3.6490088139048595E+02  bits = 18673

Min, max, mean, bit count for every diagnostic


Verification Testing
====================

.. image:: img/mom_verify.svg
   :width: 80%

.. notes::

   - Also called "invariance tests"

   - Configured for different compilers, environments

   - Platform-independent:
      - no reference answers
      - identical comparisons

   - "Regression" test for reference code (e.g. ``main``)


Verification Tests
==================

==========  =================================
Test        Description
==========  =================================
grid        Symmetric/Asymmetric memory grids
layout      1×1 and 2×1 domain decomposition
restart     Restart at mid-run
dimension   Dimensional scaling
rotation    Index rotation
openmp      OpenMP (single-thread)
==========  =================================

.. removed

   repro       Optimized reproducible mode
   nan         NaN array initialization


Validation Testing
==================

.. image:: img/mom_validate.svg

.. notes::

   - Specified for *our* machine

   - *Does* have reference answers

   - Very strict testing


Production Runs
===============

Idealized and production configs (incl. publications)

* Ocean-only

* Ocean - Sea Ice

* Coupled (Atmosphere - Sea Ice - Ocean)

Final Evaluation:

* Active GFDL development models


External Testing
================

.. image:: img/gitrepos.svg
   :width: 50%

.. notes::

   Merge to the ``main`` branch:

   Code is synced across labs periodically

   Other labs design their own regression suite

   Any regressions are resolved collaboratively

   We also have bi-weekly meetings and keep in touch regularly


Testing Summary
===============

* Automated Verification Tests

  - Small, designed to run on any system

* Regression Testing

  - 61 tests, up to 500 cores, specialized facility

* Internal validation

  - Active production runs

* Cross-site review


Floating Point Review
=====================

.. image:: img/ieee_float_fmt.svg
   :target: https://commons.wikimedia.org/wiki/File:Float_example.svg

.. math::

   \phi \equiv (-1)^\color{yellow}{s} \times 2^\color{aquamarine}{M}
      \times (1 + \color{pink}{\alpha})

* Smallest fractional diff: :math:`2^{-52} \approx 2.2 \times 10^{-16}`

* 17 digits to uniquely specify a result

.. notes::

   Things we ignore:
   - Inf and NaN
   - Denormals

   We will return to negative zero.

   Exponent manipulation is *associative* integer arithmetic


Addition Associativity
======================

What is :math:`10^{-16} + 1 - 1`?

.. math::

   (10^{-16} + 1) - 1 &\equiv 0 \\
   10^{-16} + (1 - 1) &= 10^{-16}

Residuals below ULP (:math:`2\times10^{-16}`) are lost.

.. notes::

   ULP: Unit of least precision (or lowest bit)

   10^-16 is below the current ULP (2x10^-16), so is lost in the first example.

   Cancellation in the second summation shifts ULP, preserving 10^-16.


Floating residual
=================

Let :math:`s = 1 + 2 \times 10^{-16}`.  What is :math:`(s + 1) - 1`?

.. math::

   s + 1 &= 2 \\
   (s + 1) - 1 &= 1 \neq s

Manipulation of :math:`s` shifts ULP to :math:`4 \times 10^{-16}`.

.. notes::

   Nearly identical issue, but illustrates a 2x increase in ULP


Multiplication associativity
============================

If :math:`a = b = 1.5`, and :math:`c = 1 + 2^{-52}`, then

.. math::

   (a \times b) \times c &\equiv 2.25 + 2^{-51} \\
   a \times (b \times c) &\equiv 2.25 + 2^{-50}

.. notes::

   Multiplication is less volatile:

   - Exponents are integer arithmetic -> associative

   - Only fractional part is non-associative

   - frac can only increase (not decrease) ULP, dropping last bit

   Note: Actual results depend on rounding rules


Explicit Ordering
=================

Ambiguous ordering is rejected:

.. math::

   x + y + z

Parentheses are *required*:

.. math::

   (x + y) + z \\
   x + (y + z)

Select to optimize accuracy and performance.

.. notes::

   Accuracy: Preserve residuals

   Performance: Gather repeated values (for example)


Implementation
--------------

GCC Fortran

.. code:: sh

   gfortran -fprotect-parens ...    # default
   gfortran -Ofast ...              # Sets -fno-protect-parens

Intel Fortran

.. code:: sh

   ifort -assume protect-parens     # Not default

Note: Fortran requires this!

.. notes::

   We generally avoid -fp-model style flags

   If anyone asks: J3/18-007r1, 10.1.5


Parallel Summation
==================

Parentheses work, but can be problematic:

.. math::

   \sum{\phi} = (\phi_1 + (\phi_2 + ( \phi_3 + ... )))

We recommend fixed-precision summation:

.. image:: img/fixedprec.svg
   :target: https://doi.org/10.1016/j.parco.2014.04.007

Absolutely *NO* ``sum()`` calls!

.. notes::


   Parentheses are OK for cumulant sums, but there are problems:

   - Must gather to one rank/thread before summing

   - Cumulant errors depend on order, threaten accuracy

   Cumulant sums over multiple bins resolve these issues.

   Hallberg and Adcroft, 2014: An Order-invariant Real-to-Integer Conversion
   Sum.  Parallel Computing, 40(5-6), DOI:10.1016/j.parco.2014.04.007


Transcendentals
===============

How is ``sin(x)`` computed?

.. math::

   f(48^\circ) = 2 \Omega \sin \left( \frac{48 \pi}{180} \right)

.. code:: bash

   glibc 2.22: 0.108381727637274115E-03 (3F1C695FE71A3FE4)
         2.26: 0.108381727637274128E-03 (3F1C695FE71A3FE5)

Other compilers may not even use libm!


Higher order powers
===================

How to evaluate :math:`z^6`?

These forms are ambiguous:

.. code:: fortran

   z6 = z * z * z * z * z * z

Compilers may use libm ``pow()``, also ambiguous.

We recommend::

      z3 = z * z * z
      z6 = z3 * z3

(Quiz: Why not ``(z * z) * z``?)

.. notes::

   ``pow()`` is likely to be implementation dependent.


.. Vectorization Invariance
   ========================

   - Expressions ought to give identical answers for SSE and AVX (for example)
   - Not anywhere close yet...
   - Also: We want to choose AVX-optimal parentheses


Negative Zero
=============

Although ``-0 == 0``, bitcounts will differ.

.. math::

   x \times 0 =
   \begin{cases}
       0 & \text{if $x \leq 0$} \\
      -0 & \text{if $x < 0$}
   \end{cases}

:math:`0 \Leftrightarrow -0` transitions can detect unexpected values.

But if all else fails: ``-0. + 0. == 0.``

.. notes::

   Challenge of -0: Identical to +0 for all practical purposes.

   But a ``-0`` during testing may be a prelude to a more serious problem in
   production.

   Examples of volatility:

   - Incomplete initialization

   - Incomplete rotation

   Issues in halos are not uncommon.


Subroundoff
-----------

Thickness-weighted mean:

.. math::

   \overline{\phi} = \frac{\sum \phi_i h_i}{\sum h_i}

What if all :math:`h_i = 0`?  Use subroundoff:

.. math::

   \overline{\phi} = \frac{\sum \phi_i h_i}{\sum h_i + h_\text{sub}}

:math:`h_\text{sub}` is small enough s.t. :math:`h_i + h_{sub} = h_i`.

.. notes::

   Not a bit reproducibility method, but relevant to how we manage such
   calculations.

   I think this relies on throttling of :math:`h_i` to "angstroms".


Associative Scaling
===================

Recall the floating point format

.. math::

   \phi \equiv (-1)^{\color{yellow}s} \times 2^{\color{yellow}M}
      \times (1 + {\color{yellow}\alpha})

Power-of-two multiplication is associative

.. math::

   2^N \times \phi \times 2^{-N} \equiv \phi

.. notes::

   ... up to over/underflow of the exponent

   - Fixed-precision sums must be unscaled to avoid over/underflow

   - Must un/rescale for external libraries (e.g. TEOS, CVMix)


Dimension Scaling
=================

Fields rescaled by dimensions should be invariant

.. math::

   u^{n+1} &= u^{n} +  \Delta t \times \mathcal{F} \\
   \color{yellow}{2^{L-T}} u^{n+1} &= \color{yellow}{2^{L-T}} u^{n}
      + \color{yellow}{2^T} \Delta t
      \times \color{yellow}{2^{L - 2T}} \mathcal{F}


GFD Scaling
===========

.. math::

   u_t + u u_x + v u_y &= -g h_x \\
   v_t + u v_x + v v_y &= -g h_y \\
   h_t + h u_x + h v_y &= 0 \\

.. list-table::

   * - Dimensions:
       * :math:`L` (horiz. length)
       * :math:`T` (time)
       * :math:`H` (layer thickness)

     - Invariants:
       * :math:`\left[ u, v \right] = L T^{-1}`
       * :math:`\left[ g \right] = L^2 T^{-2} H^{-1}`

.. notes::

   Shallow water eqns, a lower dimensional ocean model.


MOM6 Dimensionality
===================

===== =======  =================
Unit  Scaling  Name
===== =======  =================
s     T        Time
m     L        Horizontal length
m     H        Layer thickness
m     Z        Vertical length
kg/m3 R        Density
J/kg  Q        Enthalpy
===== =======  =================

.. notes::

   The currently tracked units are shown in this table.

   Salinity is a potential scaling


Horizontal Rotation
===================

.. image:: img/rotated_field.png

Rotate input fields, forcing, coordinates.

``(x,y)`` and ``(u,v)`` describe first and second index

.. notes::

   We call this an "index rotation" because even the coordinates are rotated.

   - Fields, grid, topography are rotated

   - Even "latitude" and "longitude" are rotated.

   - (X, Y) and (U, V) refer to the first and second index, not physical
     directions.

   This is why I resist calling it a "solid body rotation".


Index Rotation
==============

.. list-table::

   * - .. image:: img/rotate_grid1.svg
          :width: 70%

     - .. image:: img/rotate_grid2.svg
          :width: 70%

.. image:: img/rotate_mem.svg
          :width: 65%


.. notes::

   Perhaps "rotation" is not the best term, since it is more like a reordering
   of the array.

   But I think it is accurate to call it a rotation of the index map, hence the
   term "index rotation".


Applying the Rotation
=====================

.. list-table::

   - * .. image:: img/rotate_procedure.svg

     * Read inputs on coupler grid

       Move to rotated MOM6 grid

       De-rotate fields sent back to coupler and output

.. notes::

   All rotations are handled internally.

   Users do not need to manually apply any rotations.


Rotational Pairs
================

For 90° rotations:

.. list-table::

   - * Scalar
     * - :math:`\phi(I,J) = \phi(j, N-i)`

   - * Array pair
     * - :math:`\phi_u(I, J) = \phi_v(j, N-i)`
       - :math:`\phi_v(I, J) = \phi_u(j, N-i)`

   - * Vector
     * - :math:`u(I, J) =  v(j, N-i)`
       - :math:`v(I, J) = -u(j, N-i)`

.. notes::

   More generally, a rotation is a reverse+transpose of the fields


Rotational Consistency
======================

.. code:: fortran

   beta_topo_x = -CS%MEKE_topographic_beta * FatH * 0.5 * ( &
                 (G%bathyT(i+1,j)-G%bathyT(i,j)) * G%IdxCu(I,j)  &
             / max(G%bathyT(i+1,j),G%bathyT(i,j), GV%H_subroundoff) &
         +       (G%bathyT(i,j)-G%bathyT(i-1,j)) * G%IdxCu(I-1,j) &
             / max(G%bathyT(i,j),G%bathyT(i-1,j), GV%H_subroundoff) )

   beta_topo_y = -CS%MEKE_topographic_beta * FatH * 0.5 * ( &
                 (G%bathyT(i,j+1)-G%bathyT(i,j)) * G%IdyCv(i,J)  &
             / max(G%bathyT(i,j+1),G%bathyT(i,j), GV%H_subroundoff) + &
                 (G%bathyT(i,j)-G%bathyT(i,j-1)) * G%IdyCv(i,J-1) &
             / max(G%bathyT(i,j),G%bathyT(i,j-1), GV%H_subroundoff) )

Index rotation ensures directional consistency


Invariant stencils
==================

:math:`\phi^{(c)}_{i,j} = \frac{1}{4} (\phi_A + \phi_B + \phi_C + \phi_D)`

.. image:: img/stencil.svg
   :class: float

.. list-table::

   * - .. image:: img/stencil1.svg

     - :math:`\frac{1}{4} ( (\phi_A + \phi_B) + (\phi_C + \phi_D) )`

       :math:`\frac{1}{4} ( (\phi_A + \phi_C) + (\phi_B + \phi_D) )`

   * - .. image:: img/stencil2.svg

     - :math:`\frac{1}{4} ( (\phi_A + \phi_D) + (\phi_B + \phi_C) )`

.. notes::

   Example: Interpolation from vertex to center point

   The ideal outcome is to construct the stencil in a rotationally invariant
   form.

   The first example will evaluate its terms in a different order after a
   quarter turn.

   The second form is rotationally invariant to any number of quarter turns.


Rotational ordering
===================

.. code:: fortran

   subroutine advect_tracer(...)
      ! ...
      x_first = modulo(turns, 2) == 1
      if (x_first) then
         call advect_x(...)
         call advect_y(...)
      else
         call advect_y(...)
         call advect_x(...)
      endif
   end subroutine advect_tracer

When all else fails, reorder the algorithm.

.. notes::

   This is a last resort, but may be required if complexity has grown out of
   control.


Examples
========


Dimensional scaling example
---------------------------

https://github.com/NOAA-GFDL/MOM6/pull/921

.. code:: fortran

   Kd_lay(i,j,k-1) = Kd_lay(i,j,k-1) + 0.5**KS_extra(i,K)
   Kd_lay(i,j,k)   = Kd_lay(i,j,k)   + 0.5**KS_extra(i,K)

:math:`\ldots + \left(\tfrac{1}{2}\right)^{\kappa_S}`?

.. notes::

   Actually discovered during implementation of the dimensional scaling, rather
   than detected by the dimensional scaling test.  But it's the sort of thing
   that would have been found...


Rotational example
------------------

https://github.com/NOAA-GFDL/MOM6/pull/1050

.. code:: fortran

   subroutine thickness_diffuse_full
      !...
      Work_u(I,j) = Work_u(I,j) + G_scale * (...)
      Work_v(i,J) = Work_v(i,J) - G_scale * (...)
      !...
   end subroutine thickness_diffuse_full



Summary
=======

* Bit reproducibility is essential, and achievable!

* Enables aggressive regression testing

  - Dimensional consistency

  - Rotationally symmetric solvers

* Methods for bit reproducibility

  - Use parentheses for arithmetic operations.

  - Avoid ambiguous intrinsics: ``sum()``, ``sin()``, ...

